import * as fs from "fs";
import * as path from "path";
import { Logger } from "../type/logger";
import { ResourceLanguage } from "i18next";
import { unionKeys } from "./union-keys";
import { UnionKeysObject } from "../type/union-keys-object";

const UNDEFINED_MESSAGE = "ðŸš¨ðŸš¨ðŸš¨ undefined ðŸš¨ðŸš¨ðŸš¨";

/**
 * Load the JSON files for each language.
 */
export function loadTranslations(localesDir: string, languages: string[]): Record<string, ResourceLanguage> {
  const translations: Record<string, ResourceLanguage> = {};
  languages.forEach((lang) => {
    const filePath = path.join(localesDir, `${lang}.json`);
    if (!fs.existsSync(filePath)) {
      throw new Error(`File not found: ${filePath}`);
    }
    translations[lang] = JSON.parse(fs.readFileSync(filePath, "utf-8"));
  });
  return translations;
}

function isValidIdentifier(identifier: string) {
  try {
    new Function(`var ${identifier}`);
  } catch {
    return false;
  }
  return true;
}

/**
 * Retrieve the value from an object using an array of keys.
 */
function getValueByPath(obj: ResourceLanguage, pathArr: string[]): string | ResourceLanguage | undefined {
  // eslint-disable-next-line  @typescript-eslint/no-explicit-any
  return pathArr.reduce((acc: any, cur) => {
    if (acc && typeof acc === "object" && cur in acc) {
      return (acc as ResourceLanguage)[cur];
    }
    return undefined;
  }, obj);
}

/**
 * Generate a TypeScript object literal string from a translation object.
 */
export function generateLocaleObject(
  obj: UnionKeysObject,
  languages: string[],
  translations: Record<string, ResourceLanguage>,
  keyPath: string[] = [],
  depth = 0,
): string {
  let output = "{\n";
  for (const key in obj) {
    if (typeof obj[key] === "object") {
      output += withIndent(
        `${key}: ${generateLocaleObject(obj[key], languages, translations, keyPath.concat(key), depth + 1)},\n`,
        depth + 1,
      );
    } else {
      const fullKey = keyPath.concat(key).join(".");
      const commentLines = ["/**"];
      languages.forEach((lang, index) => {
        const value = getValueByPath(translations[lang], keyPath.concat(key));
        commentLines.push(` * ${lang}: ${value ?? UNDEFINED_MESSAGE}`);
        if (index !== languages.length - 1) {
          commentLines.push(" *");
        }
      });
      commentLines.push(" */\n");
      const comment = commentLines.map((l) => withIndent(l, depth + 1)).join("\n");
      output += comment;

      const _key = isValidIdentifier(key) ? key : `"${key.replace(/"/g, '\\"')}"`;
      output += withIndent(`${_key}: "${fullKey.replace(/"/g, '\\"')}",\n`, depth + 1);
    }
  }
  output += withIndent("}", depth);
  return output;
}

function withIndent(text: string, depth: number, tabSize: number = 2) {
  return `${" ".repeat(depth * tabSize)}${text}`;
}

function toCamelCase(str: string) {
  return str.replace(/([-_][a-z])/gi, (group) => group.toUpperCase().replace(/[-_]/, ""));
}

/**
 * Generate TypeScript file content from translations for the specified namespace.
 */
export function generateLocaleFileContent(
  resourceLanguages: Record<string, ResourceLanguage>,
  namespace: string | undefined,
  languages: string[],
  defaultName: string,
  logger?: Logger,
): string {
  const baseLang = languages[0];
  const baseTranslation = resourceLanguages[baseLang];
  const namespaceObj = namespace != null ? baseTranslation[namespace] : baseTranslation;
  if (namespaceObj == null) {
    const message = `Namespace '${namespace}' not found in ${baseLang}.json`;
    logger?.error(message);
    throw new Error(message);
  }

  const namespaceObjs: ResourceLanguage[] = languages.map((lang) => {
    const t = resourceLanguages[lang];
    const ns = namespace != null ? t[namespace] : t;
    return ns && typeof ns === "object" ? (ns as ResourceLanguage) : {};
  });
  const mergedNamespaceObj = unionKeys(namespaceObjs);

  const camelCaseDefaultName = toCamelCase(defaultName);
  const _defaultName = isValidIdentifier(camelCaseDefaultName) ? camelCaseDefaultName : `__${camelCaseDefaultName}`;

  const localeObjectStr = generateLocaleObject(mergedNamespaceObj, languages, resourceLanguages, [], 0);
  return `/*
 * This file is automatically generated.
 * Manual modifications may be overwritten.
 */
const ${_defaultName} = ${localeObjectStr} as const;

export default ${_defaultName};
`;
}
